// 闭包与内存管理
// 闭包与内存泄漏问题

// 闭包的形成: 内部函数访问到外部函数的作用域时就形成了闭包
// 内存泄露: 如果闭包的作用域链中保存着一些Dom节点,这个时候可能造成内存泄漏; IE浏览器中BOM DOM 对象使用C++以COM对象的方式实现的
// COM对象的垃圾收集机制使用的是计数策略,
// 内存回收: 将循环引用中的变量置为null 下次垃圾回收器执行就会删除这些值回收他们占用的内存

// 作用域链[[Scopes]]
// 全局代码存储其变量的地方叫做变量对象（VO），函数存储其变量的叫活动对象（AO），VO 和 AO 都是在预编译时确定其内容，然后在代码运行时被修改值。
// 每一个函数都有一个 [[Scopes]] 属性，其存储的是这个函数运行时的作用域链
// 除了当前函数的 AO，作用域链的其他部分都会在其父函数预编译时添加到函数的 [[Scopes]] 属性上（因为父函数也需要预编译后才能确定自己的AO），所以 js 的作用域是词法作用域。

// 1. global.VO = { t }
var t = 111;
function fun() {
  // 3. fun.AO = { a, b }
  var a = 1;
  var b = 2;
  function fun1() {
    // fun1.AO = {c}
    var c = 3;
  }
  // 4. fun1.[[Scopes]] = [...fun.[[Scopes]], fun.AO]
  fun1()
}
// 2. fun.[[Scopes]] = [global.VO]
fun();
// 上面代码在 fun() 被调用前，会立即预编译 fun 函数，这一步会得到 fun 的活动对象（AO），然后运行 fun 函数，在执行到 let a = 1 的时候，会将变量对象到 a 属性改成 1。后面也是一样

// [[Scopes]] 就像一个数组一样，每一个函数的 [[Scopes]] 中都存在当前函数的 AO 和上级函数的 [[Scopes]]。
// 在函数运行时会优先取距离当前函数 AO 近的变量值，这就是作用域的就近原则。

// 上面介绍的 [[Scopes]] 可能就是大家熟知的，这在以前是对的。

// 但是最新的 V8 中已经发生了变化（Chrome 中已经可以看到这些变化）

// 在为一个函数绑定词法作用域时，并不会粗暴的直接把父函数的 AO 放入其 [[Scopes]] 中，

// 而是会分析这个函数中会使用父函数 AO 中的哪些变量，而这些可能会被使用到的变量会被存储在一个叫做 Closure 的对象中

// 每一个函数都有且只有一个 Closure 对象，最终这个 Closure 将会代替父函数的 AO 出现在子函数的 [[Scopes]] 中。

// 在V8中每一个函数执行前都会进行预编译，预编译阶段都会执行3个重要的字节码

// CreateFunctionContext 创建函数执行上下文

// PushContext 上下文入栈

// CreateClosure 创建函数的闭包对象

// 每一个函数执行前都会创建一个闭包，无论这个闭包是否被使用，那么闭包中的内容是什么？如何确定其内容？

// Closure 跟 [[Scopes]] 一样会在函数预编译时被确定，区别是当前函数的 [[Scopes]] 是在其父函数预编译时确定， 而 Closure 是在当前函数预编译时确定（在当前函数执行上下文创建完成入栈后就开始创建闭包对象了）。

// 当 V8 预编一个函数时，如果遇到内部函数的定义不会选择跳过，而是会快速的扫描这个内部函数中使用到的本函数 AO 中的变量，然后将这些变量的引用加入 Closure 对象。再来为这个内部函数函数绑定 [[Scopes]] ，并且使用当前函数的 Closure 作为内部函数 [[Scopes]] 的一部分。

// 每一次遇到内部声明的函数/方法时都会这么做，无论其内部函数/方法的声明嵌套有多深，并且他们使用的都是同一个 Closure 对象。并且这个过程 是在预编译时进行的而不是在函数运行时。

// 1. global.VO = {t}
var t = 111;
// 2. fun.[[Scopes]] = [global.VO]
function fun() {
  // 3. fun.AO = { a, b } 并创建一个空的闭包对象 fun.Closure = {}
  var a = 1, b = 2, c = 3;
  // 4. 遇到函数, 解析到函数会使用 a, fun.Closure = { a }
  // 5. fun1.[[Scopes]] = [global.VO, fun.Closure]
  function fun1() {
    debugger;
    console.log(a);
  }
  fun1()
  // 6. 遇到函数, 解析到函数会使用 b, fun.Closure = { a, b }
  // 7. fun2.[[Scopes]] = [global.VO, fun.Closure]
  function fun2() {
    debugger;
    console.log(b);
  }
  fun2()
}
// 执行到这里时预编译 fun
// 1、2发生在全局代码的预编译阶段，3、4、5、6、7发生在 fun 的预编译阶段。
fun()
// fun1 执行时的作用域链是这样的：[fun1.AO, fun.Closure, global.VO]
// 所有子函数使用的是同一个闭包对象
// Closure 中的变量存储的是对应变量的引用地址，如果这个变量值发生变化，那么 Closure 中对应的变量也会发生变化

// 每一个函数都会产生闭包，无论 闭包中是否存在内部函数 或者 内部函数中是否访问了当前函数变量 又或者 是否返回了内部函数，因为闭包在当前函数预编译阶段就已经创建了。